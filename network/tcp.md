### tcp 报文结构

- 源端口号
- 目的端口号
- 顺序号 (sequence number)
- 确认号 (acknowledgement number)
- URG, ACK, PSH, RST, SYN, FIN 标志位
- 窗口大小 (网络拥塞算法所用)
- 校验和 (checksum)
- 紧急指针
- 数据 (也就是 http 报文)

### tcp 网络拥塞算法

tcp 是一个可靠的传输的协议，至于说为什么可靠，其中一个原因是保证接收方能完整收到发送方的信息。它可以进行调节，防止过多的数据注入至网络而出现负载过大的情况，这种调节过程可称为网络拥塞算法。它大概分成四个部分：慢启动、拥塞避免、快重传、快恢复。

#### 慢启动

在 tcp 建立连接时，接收方会根据自身数据接受能力给发送方一个**阈值**，它将会作用于后面的拥塞窗口大小的调节。发送方维护一个**拥塞窗口** (congestion window 简称 cwnd)的变量，标识着传递数据的大小，它取决于网络的拥塞程度，并且会动态变化，它的初始值为**最大分段大小** (maximum segment size 简称 mss)。大概的思路是：一开始不要发送大量的数据，而是从小量开始，不断增大并且探测网络的拥塞程度。当然，为了防止拥塞窗口增长过大，还需设置一个**慢启动阈值** (slow start threshold 简称 ssthresh)。

流程如下：

- 当 cwnd > ssthresh 时，慢启动结束，改用拥塞避免算法
- 当 cwnd < ssthresh 时，拥塞窗口大小呈指数增长（1, 2, 4, 8 ...）

#### 拥塞避免算法

拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。当然，增长也是受到前文提及的发送方接受能力的阈值所限制的。

无论是在慢启动阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，则会做相应处理。这里会怎么判断出现网络拥塞呢？- 没有按时收到确认包。此时将会把**慢启动阈值设为目前拥塞窗口大小的一半**，然后把拥塞窗口也置为该值，继续执行拥塞避免算法 (TCP Reno 版本)，实际上这个处理是快恢复算法做的。

注意："拥塞避免" 并非完全能够避免了阻塞，而是使网络比较不容易出现拥塞。

#### 快重传算法

快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，**发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段**，而不必继续等待设置的重传计时器时间到期。

#### 快恢复算法

快重传配合使用的还有快恢复算法，有以下两个要点：

- 当发送方连续收到三个重复确认时，就执行 "乘法减小" 算法，把 ssthresh 减半（为了预防网络发生拥塞）。但是接下去并不执行慢启动算法
- 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞，而是数据丢失。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 减半后的值，然后执行快重传算法，立即发送缺失的报文段。同时执行快恢复算法：将 ssthresh 调整为此时 cwnd 的一半，并执行拥塞避免算法。

注意：在采用快恢复算法时，慢开始算法只是在 TCP 连接建立时和网络出现超时时才使用

#### 不同版本的处理

- TCP Tahoe (已废弃)：发生丢失时，慢启动阈值设为之前拥塞窗口值的一半，拥塞窗口值降为初始值，重新进入慢启动阶段
- TCP Reno 则将慢启动阈值设为之前拥塞窗口值的一半，和作为新的拥塞窗口值，并跳过慢启动阶段，直接进入拥塞控制阶段

注意：前文的描述是基于 Reno 版本的
