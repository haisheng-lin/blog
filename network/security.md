### XSS

XSS 名为跨站脚本攻击，是指通过存在安全漏洞的网站浏览器内运行非法的 html 标签或 JavaScript 脚本的一种攻击。

原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。

#### 非持久型 (反射型) XSS

非持久型 XSS 漏洞，一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。

譬如，攻击者可直接通过 url 如 `https://xxx.com/xxx?default=<script>alert(document.cookie)</script>` 注入可执行的脚本，不过一些浏览器如 Chrome 其内置了一些 XSS 过滤器，可以防止大部分反射型 XSS 攻击。

#### 持久型 (存储型) XSS

持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。

#### 如何防御

第一种方法：**建立白名单**，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。

通常可以通过两种方式来做：

- 设置 HTTP Header 中的 Content-Security-Policy
- 设置 meta 标签的方式

只允许加载本站资源:

```
Content-Security-Policy: default-src 'self'
```

只允许加载 HTTPS 协议图片

```
Content-Security-Policy: img-src https://*
```

对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。

第二种方法：**转义字符**，对于引号、尖括号、斜杠等特殊字符进行转义

### CSRF

CSRF 即跨站请求伪造，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。

完成 CSRF 攻击必须要有三个条件：

- 用户已经登录了站点 A，并在本地记录了 cookie
- 在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点 A)。
- 站点 A 没有做任何 CSRF 防御

#### 如何防御

第一种方法：**SameSite**，可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。

第二种方法：**Referer Check**，当浏览器向服务器发送请求时，一般会带上 Referer 信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御 CSRF 攻击。

第三种方法：**Anti CSRF Token**，即发送请求时在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器建立一个拦截器来验证这个 token。服务器读取浏览器当前域 cookie 中这个 token 值，会进行校验该请求当中的 token 和 cookie 当中的 token 值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。

其实一般工作来说，我们通常用 json web token 进行用户身份校验，它需要在手动添加到请求头，而不是像 cookie 那样可能会自动带上，所以它是可以防止 CSRF 攻击的。

### DNS 劫持

DNS 是一种根据域名查询 ip 地址的服务，DNS 劫持就是说攻击者拦截发送方请求，并将 ip 地址解析为自己的恶意服务器，从而阻断客户端与服务端的正常通信。

### 运营商劫持

运营商也是可以监听并篡改网络请求和响应的，譬如说它可以给服务器返回的 html 字符串添加上自己的恶意广告

#### 如何防御

第一种方法：上 HTTPS 协议，防止数据被监听和篡改（严格来说依然是可篡改，但是至少我们知道了）

第二种方法：对返回的 html 内容进行 clean 操作，只保留自己代码所识别的内容
