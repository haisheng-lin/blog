### http 报文结构

http 报文由请求行（request line）、请求头（header）、空行和请求体四个部分组成。

#### 请求行

请求行包括请求方法、请求路径、http 版本组成，它们之间由一个空格隔开，如：

```
POST /index.html HTTP/1.1
```

#### 请求头

请求头由多个键值对组成，每行一对，键与值之间用 `:` 分隔，如：

```
HOST: www.baidu.com
Connection: keep-alive
Accept-Encoding: gzip, deflate, sdch
```

#### 请求体（非必须）

**请求头与请求体之间会有一个空行，它意味着请求头部分结束，进入正文部分**

请求体可以承载请求参数的数据，譬如 POST 请求所携带的数据会存在请求体中，如：

```
{"user":1,"password":"xxx"}
```

#### 完整的 http 报文例子

```
GET / HTTP/1.1
Host: www.enjoytoday.cn
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.84 Safari/537.36
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Referer: http://www.enjoytoday.cn/posts/326
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8
Cookie: bdshare_firstime=1466032270994; UM_distinctid=15c4ef2ac4e2e4-0d13269271b947-1b2a120b-1fa400-15c4ef2ac4f7b5; un=aGZjYWk=; comment_author=aGZjYWk=; comment_author_email=1710600212@qq.com; comment_author_url=http://www.enjoytoday.cn; c_id=dUhIaTlndmc4MVVYbjRQTGxMRTotMTpFODg3QjgzQjg1NjgxQjQxRUYxNjg2QzJFRkMyQjI2QQ==; JSESSIONID=ADBC8C3DADF6C815D778450C193C6637.ajp13_worker; Hm_lvt_ce55bfda158556585a8b7b246346c8ba=1498560244,1498739070,1498833193,1498917432; Hm_lpvt_ce55bfda158556585a8b7b246346c8ba=1498917597; CNZZDATA1262047894=1598545996-1495973145-%7C1498917578

{"user":1,"password":"xxx"}
```

### GET 与 POST 区别

个人理解：实质区别仅仅在于 http 报文头请求方法不一样，但是浏览器会根据规范对它们做出不一样的行为，仅此而已（这也是我面试时回答的）。接下来谈谈浏览器对它们的行为有何差别：

- GET 在浏览器回退时是无害的，而 POST 会再次提交请求
- GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置
- GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留
- GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有限制
- GET 参数通过 URL 传递，POST 放在请求体

### http 连接管理

#### 短连接 (http/1.0)

使用短连接的传输模型，会每发送一次 http 请求，客户端都会与服务端建立一次 tcp 连接，在收到响应后释放掉。然而每次打开新的 tcp 连接，是一个耗费资源的操作，在浏览器动辄发送十几个甚至更多请求的今天，显然这种低效的模型是不适用的。

> 除非是要兼容一个非常古老的，不支持长连接的系统，没有一个令人信服的理由继续使用这个模型。

#### 持久连接 (http/1.1 以上)

长连接意味着在同一个 tcp 连接，可以发送多个 http 请求。在 http/1.1 中，`Connection` 被写入请求头的标准，如果设置 `Connection: keep-alive`（或者不写），将会使用长连接作为传输模型。

一个长连接会保持一段时间，重复用于发送一系列请求，节省了新建 TCP 连接握手的时间，还可以利用 TCP 的性能增强能力。当然这个连接也不会一直保留着：连接在空闲一段时间后会被关闭(服务器可以使用 Keep-Alive 协议头来指定一个最小的连接保持时间)。

然而长连接依然存在一些问题：当发送 http 请求收到响应后，才会发起下一个请求，所以后面的请求会被前面的阻塞。另外，长连接就算是在空闲状态，它还是会消耗服务器资源。

#### 流水线 (http/1.1 以上)

流水线相对于长连接的优化在于：可以同时发起多个 http 请求，但是他们必须有序的发送，而且服务器需要根据这个顺序返回响应。在客户端，它确实优化了阻塞发送请求的问题，但是在服务端的问题依然没有得到解决。（这个问题称为 [head of line blocking](https://en.wikipedia.org/wiki/Head-of-line_blocking)）

而且，流水线模型已经被更好的模型所代替！

#### 多路复用 (http/2 以上)

多路复用是 http/2 的特性之一，http2 之前的协议是基于文本的，http/2 则是基于数据流的。什么意思呢？在 http/1.1 的协议中，传输的 request 和 response 都是基本于文本的，这样就会引发一个问题：所有的数据必须按顺序传输，比如需要传输：hello world，只能从 h 到 d 一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在 http/1.1 是不能实现的。

在 http/2 中，会把请求与响应的数据切分成多个数据流，并赋予每个流一个流 id（识别对应哪个请求、以及数据中的顺序），然后并行传输。收到流后，根据流 id 按序将数据拼装，正确地还原出来，所以流之间的传输是可以乱序的。

另外，在 http/1.1 中，由于上述的限制，要使得并发多个请求，只能建立多个 tcp 连接（题外话：浏览器同一域名下的最大 tcp 连接数是 6，也就是只能做到并发 6 个请求，如果要增大并发数的话只能使资源存放在不同域名下）。但是 http/2 有了数据流后，则不需依赖多个 tcp 连接，从而减小了资源耗费。

#### 小思考

以前我们常说的一种网络性能优化方案是合并资源文件，从而减少 http 请求数。但是在开发中，我们会把项目分成多个模块，如果只改了某个模块，则合并后的打包文件改变了，无法缓存。现在我们有 http2 优化了网络传输性能，该模块可以单独改变，而保持其他文件不变，从而可使用缓存。

### http 版本进化的优势

#### http/1.1

上文提到了，http/1.1 主要的优势是支持持久连接，减小 tcp 连接的建立与释放

#### http/2

但是 http/1.1 依然存在一些问题，就如上文提到的**队头阻塞**问题，导致后发请求可能有高延迟的风险。所以 http/2 带来的多路复用特性便很好的解决这个问题。另外传输的数据量也大幅减少，主要是通过**二进制方式传输和头部压缩**实现的。

头部压缩是指：在客户端和服务器两端建立 "字典"，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率。具体来说:

- 在客户端和服务器端使用 "首部表" 来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送
- 首部表在 http/2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新

个人理解：字典是唯一编号与具体值的映射关系，例如客户端只要给个编号，服务端拿到编号后就知道对应的是哪个请求头；服务端发送响应给客户端也是同理的。

很多主流浏览器如 chrome, firefox 都宣布只支持加密的 http/2，所以即使 http/2 本身出于兼容的考虑，延续了 http/1.1 明文传输的特点，但实际上可以理解成是有加密的。

http/2 还在一定程度上改变了传统的 "请求-应答" 工作模式，服务器不再是完全被动地响应请求，也可以新建 "流" 主动向客户端发送消息。

总结：

- 多路复用、头部压缩加快了数据传输的效率
- 安全性可以理解为比 http/1.1 提高了
- 增加了服务端向客户端推送消息的功能

### https

由于 http 明文传输的特性，导致数据之间的传输不安全，https 的出现很好的解决了这些问题。

#### 加密：解决内容可能被窃听的问题（应用在最外部，为后面其他保证的基础）

在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式。

具体做法是：发送密文的一方使用对方的公钥进行加密处理 "对称的密钥"，然后对方用自己的私钥解密拿到 "对称的密钥"，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信

#### 数字签名：解决报文可能遭篡改问题

虽然数据无法被解密，但可能被篡改，如何校验数据的完整性？--- 数字签名

数字签名是指发送方使用自己的私钥加密得到的密文数据，它意味着消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。具体是怎样做的呢？

- 将一段文本先用 Hash 函数生成消息摘要，然后用发送者的私钥加密生成数字签名；与原文一起传送给接收者
- 接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用 HASH 函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性

#### 流程描述

- 客户端发起 https 请求
- TCP 连接，下面开始 TLS 握手
- 双方参数协商（包括密码套件、随机数等，这里比较复杂）
- 服务端返回事先配置好的公钥证书
- 客户端验证证书的有效性：读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的 (安全起见，CA 公钥在浏览器安装时会被内置而不是向 CA 请求)
- 客户端生成随机密钥，用服务端的公钥加密，加密后的数据发送给服务端
- 服务端用私钥解密得到随机密钥，至此双方都知道本次请求使用加密的密钥
- 服务端使用对称密钥加密 "明文内容 A"，发送给客户端
- 客户端也使用对称密钥加密的方法对服务端发送 "明文内容 B"
- 至此，双方都知道对方已经得到随机密钥了，于是可以开始通信

#### 成本

尽管 https 如此安全可靠，但是并不是所有网站都使用它，因为有一定的成本与代价：

- 与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源
- 想要节约购买证书的开销也是原因之一。要进行 https 通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买
